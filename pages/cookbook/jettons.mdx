# Fungible Tokens (Jettons)

import { Callout } from 'nextra-theme-docs';

This page lists common examples of working with [jettons](https://docs.ton.org/develop/dapps/asset-processing/jettons).

## Accepting jetton transfer

Transfer notification message have the following structure.

```tact
message(0x7362d09c) TransferNotification {
    queryId: Int as uint64;
    jettonAmount: Int as coins;
    fromAddress: Address;
    forwardPayload: Slice as remaining;
}
```

Use [receiver](/book/receive) function to accept token notification message.

<Callout type="warning" emoji="⚠️">

  Sender of transfer notification must be validated!

</Callout>

Validation can be done using jetton wallet state init and calculating jetton address.
Note, that notifications are coming from YOUR contract's jetton wallet, so [`myAddress()`](/ref/core-common#myaddress) should be used in owner address field.
Wallet initial data layout is shown below, but sometimes it can differ.

```tact
struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(ownerAddress: Address, jettonMasterAddress: Address, jettonWalletCode: Cell): Address {
    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{code: jettonWalletCode, data: initData.toCell()});
}

contract Sample {
    jettonWalletCode: Cell;
    jettonMasterAddress: Address;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.jettonWalletCode = jettonWalletCode;
        self.jettonMasterAddress = jettonMasterAddress;
    }

    receive(msg: TransferNotification) {
        let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
        require(sender() == myJettonWalletAddress, "Notification not from your jetton wallet!");

        // your logic of processing token notification
    }
}
```

## Sending jetton transfer

To send jetton transfer use [`send(){:tact}`](/book/send) function.
If you want to have full control over the sending process and require some complex logic for it,
use [`nativeSendMessage(){:tact}`](/ref/core-advanced#nativesendmessage) function.
Note that `myJettonWalletAddress` may also be stored in contract storage to use less gas in every transaction.

```tact
message(0xf8a7ea5) TokenTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    excessesDestination: Address;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

receive("send") {
    let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
    send(SendParameters{
        to: myJettonWalletAddress,
        value: ton("0.05"),
        body: TokenTransfer{
            queryId: 42,
            amount: jettonAmount, // jetton amount you want to transfer
            destination: msg.userAddress, // address you want to transfer jettons. Note that this is address of jetton wallet owner, not jetton wallet itself
            excessesDestination: msg.userAddress, // address were left toncoins will go
            customPayload: null, // in most cases will be null and can be omited. Needed for custom logic on jettons itself
            forwardTonAmount: 1, // amount that will be transferred with TransferNotification. Needed for custom logic execution like in example below
            forwardPayload: cell("te6cckEBAQEAAwAAAUD20kA0").beginParse(), // precomputed beginCell().storeBool(false).endCell()
        }.toCell(),
    });
}
```

## Burning jetton

```tact
message(0x595f07bc) TokenBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    excessesDestination: Address;
    customPayload: Cell? = null;
}

receive("burn") {
    let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
    send(SendParameters{
        to: myJettonWalletAddress,
        body: TokenBurn{
            queryId: 42,
            amount: jettonAmount, // jetton amount you want to burn
            excessesDestination: someAddress, // address were left toncoins will go
            customPayload: null, // in most cases will be null and can be omited. Needed for custom logic on jettons itself
        }.toCell(),
    });
}
```

## USDT jetton operations

Operations with USDT (on TON) remain the same, except that the  `JettonWalletData` will have the following structure:

```tact
struct JettonWalletData {
    status: Ins as uint4;
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
}
```

Function to calculate wallet address will look like this:

```tact
fun calculateJettonWalletAddress(ownerAddress: Address, jettonMasterAddress: Address, jettonWalletCode: Cell): Address {
    let initData = JettonWalletData{
        status: 0,
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
    };

    return contractAddress(StateInit{code: jettonWalletCode, data: initData.toCell()});
}
```

<Callout type="info" emoji="🤔">

  Didn't find your favorite example of a jettons communication? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact-docs/issues)

</Callout>
