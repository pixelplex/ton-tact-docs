import { Callout } from 'nextra-theme-docs';

This page lists common examples of working with [jettons](https://docs.ton.org/develop/dapps/asset-processing/jettons).

## Accepting jetton transfer

Transfer notification message have the following structure.

```tact
message(0x7362d09c) TransferNotification {
    queryId: Int as uint64;
    jettonAmount: Int as coins;
    fromAddress: Address;
    forwardPayload: Slice as remaining;
}
```

Use [receiver](/book/receive) function to accept token notification message.

<Callout type="warning" emoji="⚠️">

  Sender of transfer notification must be validated!

</Callout>

Validation can be done using jetton wallet state init and calculating jetton address.
Note, that notifications are coming from YOUR contract's jetton wallet, so [`myAddress()`](/ref/core-common#myaddress) should be used in owner address field.
Wallet initial data layout is shown below, but sometimes it can differ.

```tact
struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(ownerAddress: Address, jettonMasterAddress: Address, jettonWalletCode: Cell): Address {
    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{code: jettonWalletCode, data: initData.toCell()});
}

contract Sample {
    jettonWalletCode: Cell;
    jettonMasterAddress: Address;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.jettonWalletCode = jettonWalletCode;
        self.jettonMasterAddress = jettonMasterAddress;
    }

    receive(msg: TransferNotification) {
        let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
        require(sender() == myJettonWalletAddress, "Notification not from your jetton wallet!");

        // your logic of processing token notification
    }
}
```

## Sending jetton transfer

To send jetton transfer use `send` or similar [function](/book/send).
Note that `myJettonWalletAddress` may also be stored in contract storage to use less gas in every transaction.

```tact
receive("send") {
    let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
    send(SendParameters{
        to: myJettonWalletAddress,
        value: ton("0.05"),
        body: TokenTransfer{
            queryId: 42,
            amount: jettonAmount, // jetton amount you want to transfer
            destination: msg.userAddress, // address you want to transfer jettons. Note that this is address of jetton wallet owner, not jetton wallet itself
            exceesesDestination: msg.userAddress, // address were left toncoins will go
            customPayload: null, // in most cases will be null and can be ommited. Needed for custom logic on jettons itself
            forwardTonAmount: 1, // amount that will be transfered with TransferNotification. Needed for custom logic execution like in example below
            forwardPayload: beginCell().storeBool(false).endCell().beginParse(), // TODO: this is so gas consuming, maybe there is another way? Or use generic (TBD)? Or there is better way to just left it
        }.toCell(),
    });
}
```

## Burning jetton

```tact
message(0x595f07bc) TokenBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    exceesesDestination: Address;
    customPayload: Cell? = null;
}

receive("burn") {
    let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
    send(SendParameters{
        to: myJettonWalletAddress,
        body: TokenBurn{
            queryId: 42,
            amount: jettonAmount, // jetton amount you want to burn
            exceesesDestination: someAddress, // address were left toncoins will go
            customPayload: null, // in most cases will be null and can be ommited. Needed for custom logic on jettons itself
        }.toCell(),
    });
}
```

## USDT jetton operations

USDT operations remains the same except one difference - `JettonWalletData` will have the following structure:
```tact
struct JettonWalletData {
    status: Ins as uint4;
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
}
```

Function to calculate wallet address will look like this:

```tact
fun calculateJettonWalletAddress(ownerAddress: Address, jettonMasterAddress: Address, jettonWalletCode: Cell): Address {
    let initData = JettonWalletData{
        status: 0,
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
    };

    return contractAddress(StateInit{code: jettonWalletCode, data: initData.toCell()});
}
```

<Callout type="info" emoji="🤔">

  Didn't find your favorite example of a jettons communication? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact-docs/issues)

</Callout>
