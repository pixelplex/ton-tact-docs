# Non-Fungible Tokens (NFTs)

import { Callout } from 'nextra/components'

This page lists common examples of working with [NFTs](https://docs.ton.org/develop/dapps/asset-processing/nfts).

## Accepting nft ownership assign

NFT ownership assigned notification message have the following structure.

```tact
message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}
```

Use [receiver](/book/receive) function to accept notification message.

<Callout type="warning" emoji="⚠️">

  Sender of notification must be validated!

</Callout>

Validation can be done using nft item state init and calculating nft item address.
NFT Item initial data layout is shown below, but sometimes it may differ.

```tact
struct NFTItemInitData {
    index: Int as uint64;
    collectionAddress: Address;
}

inline fun calculateNFTAddress(index: Int, collectionAddress: Address, nftCode: Cell): Address {
    let initData = NFTItemInitData{
        index,
        collectionAddress,
    };

    return contractAddress(StateInit{code: nftCode, data: initData.toCell()});
}

contract Example with Deployable {
    nftCollectionAddress: Address;
    nftItemIndex: Int as uint64;
    nftCode: Cell;

    init(nftCollectionAddress: Address, nftItemIndex: Int, nftCode: Cell) {
        self.nftCollectionAddress = nftCollectionAddress;
        self.nftItemIndex = nftItemIndex;
        self.nftCode = nftCode;
    }

    receive(msg: NFTOwnershipAssigned) {
        let expectedNftAddress = calculateNFTAddress(self.nftItemIndex, self.nftCollectionAddress, self.nftCode); // or you can even store expectedNftAddress
        require(expectedNftAddress == sender(), "Sender is not expected NFT");

        // your logic of processing nft ownership assign notification
    }
}
```

## Transferring NFT item

To send jetton transfer use [`send(){:tact}`](/book/send) function.
If you want to have full control over the sending process and require some complex logic for it,
use [`nativeSendMessage(){:tact}`](/ref/core-advanced#nativesendmessage) function.

```tact
message(0x5fcc3d14) NFTTransfer {
    queryId: Int as uint64;
    newOwner: Address; // address of the new owner of the NFT item.
    responseDestination: Address; // address where to send a response with confirmation of a successful transfer and the rest of the incoming message coins.
    customPayload: Cell? = null; //  optional custom data. In most cases should be null
    forwardAmount: Int as coins; // the amount of nanotons to be sent to the new owner.
    forwardPayload: Slice as remaining; // optional custom data that should be sent to the new owner.
}

receive("transfer") {
    let nftAddress = calculateNFTAddress(self.nftItemIndex, self.nftCollectionAddress, self.nftCode);

    send(SendParameters{
        to: nftAddress,
        value: ton("0.1"),
        body: NFTTransfer{
            queryId: 42,
            newOwner: address("[NEW_OWNER_ADDRESS]"),
            responseDestination: myAddress(),
            customPayload: null,
            forwardAmount: 1,
            forwardPayload: beginCell().storeBool(false).endCell().beginParse(), // TODO: this is so gas consuming, maybe there is another way? Or use generic (TBD)? Or there is better way to just left it
        }.toCell(),
    });
}
```

## Get NFT static info

Note, that TON Blockchain does not support getter's in a native way, as Ethereum does.
In order to receive data from another contract, you must exchange messages

```tact
message(0x2fcb26a2) NFTGetStaticData {
    queryId: Int as uint64;
}

message(0x8b771735) NFTReportStaticData {
    queryId: Int as uint64;
    index: Int as uint256;
    collection: Address;
}

receive("get static data") {
    let nftAddress = address("[NFT_ADDRESS]");
    send(SendParameters{
        to: nftAddress,
        value: ton("0.1"),
        body: NFTGetStaticData{
            queryId: 42,
        }.toCell(),
    });
}

receive(msg: NFTReportStaticData) {
    let expectedNftAddress = calculateNFTAddress(msg.index, msg.collection, self.nftCode);
    require(expectedNftAddress == sender(), "Sender is not expected NFT");

    // Save nft static data or do something
}
```

## Get NFT royalty params

NFT royalty params described [here](https://github.com/ton-blockchain/TEPs/blob/master/text/0066-nft-royalty-standard.md).

```tact
receive("get royalty params") {
    send(SendParameters{
        to: self.nftCollectionAddress,
        value: ton("0.1"),
        body: NFTGetRoyaltyParams{
            queryId: 42,
        }.toCell(),
    });
}

receive(msg: NFTReportRoyaltyParams) {
    require(self.nftCollectionAddress == sender(), "Sender is not expected NFT collection");

    // Do something with msg
}
```

## NFT Collection methods

These methods are not described in any standard but commonly used across nft [contracts](https://github.com/ton-blockchain/token-contract/blob/main/nft/nft-collection.fc).
Note that they can be used by nft owner only.

### Deploy nft

```tact
message(0x1) NFTDeploy {
    queryId: Int as uint64;
    itemIndex: Int as uint64;
    amount: Int as coins; // amount to sent when deploying nft
    nftContent: Cell;
}

receive("deploy") {
    send(SendParameters{
        to: self.nftCollectionAddress,
        value: ton("0.14"),
        body: NFTDeploy{
            queryId: 42,
            itemIndex: 42,
            amount: ton("0.1"),
            content: beginCell().endCell() // Should be yout content, mostly generated offchain
        }.toCell(),
    });
}
```

### Change owner

```tact
message(0x3) NFTChangeOwner {
    queryId: Int as uint64;
    newOwner: Address;
}

receive("change owner") {
    send(SendParameters{
        to: self.nftCollectionAddress,
        value: ton("0.05"),
        body: NFTChangeOwner{
            queryId: 42,
            newOwner: address("NEW_OWNER_ADDRESS"),
        }.toCell(),
    });
}
```

<Callout type="info" emoji="🤔">
  Didn't find your favorite example of a jettons communication? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact-docs/issues)
</Callout>
